# 构建目标

---

## 目录结构

+ 众所周知，在Windows系统中，由于操作系统搜索动态链接库的规则，许多软件的安装目录都是几个可执行文件与大量动态链接库文件杂乱放置，非常不优雅。

+ 本软件是开源软件，开放用户插件接口。对于一个用户经常需要访问其安装目录的软件来说，保持安装目录的整洁性是一件重要的事。

+ 在Linux系统中，由于其搜索动态链接库的规则比Windows可定制性强，一般大型C/C++程序部署后，可执行文件所在目录可以做到很整洁，它所依赖的动态库都可以放在子目录`lib`内。

+ 因此，对于本软件的部署，我们采取一定的策略，使可执行文件能够单独放置在安装目录的根目录，动态链接库放置在子目录`lib`中，并且程序能够正常运行。这样，也尽可能保证了Windows和Linux平台下本软件安装目录结构的一致性。

+ 构建的对象一般只有三种，lib(a)、dll(so/dylib)与exe，即静态库、动态库与可执行文件，将它们统称为目标。

## 库

### 系统库

+ Windows下，在`system32`目录中，主要包括`xxx32.dll`系列与VCRuntime系列动态库
+ Linux下，在`/usr/lib`与`/usr/local/lib`中，主要包括`glibc`与`xwindow`等动态库
+ MacOS下，与Linux类似，还包括一些NS库

### 外部库

外部库是现成的二进制文件，不参与项目的编译构建。

本工程使用了大量的外部库，包括系统库、Qt库与第三方库，这些库在项目配置之前就以二进制形式存在计算机中，是项目的直接依赖。

1. Qt库
    + 本软件使用Qt 5.15.2

2. 预构建的第三方库
    + 包括FFmpeg、SDL、zlib等...
    + 你需要在拉取本仓库后执行`setup_vcpkg.py`对这些第三方库进行初始化，它们会被安装到项目目录的`vcpkg/installed/{TRIPLET}/lib`中，vcpkg提供的脚本会自动将它们引入我们的项目。

### 基础内部库

本工程也有大量的内部库，这些内部库以源码形式存在于本仓库中，参与项目的编译构建。这些内部库中，也有基础与上层之分，基础的内部库有两种。

1. 实用库
    + 这些库要么是自己编写的工具类、工具函数等的集合，要么是源码形式的第三方库

    + 为什么第三方库既有外部库又有内部库？
        + 由于“不要重复造轮子”原则，我们的项目必然会使用大量的第三方库。
        + 其中一些如`FFmpeg`、`SDL`这样的大型库，将它们从源码编译成机器码的时间很长，而且我们一般没有必要更改它们的源代码，因此将它们作为外部库使用，要么直接从互联网下载它们的动态库文件，要么在配置本工程之前就将它们编译成动态库。本工程就使用了vcpkg管理这些库。
        + 其他一些小型的第三方库，如`mrq`、`SingleApplication`，我们可能需要修改它们的源码，因此将它们的源码直接加入工程，参与本工程的构建过程。
        + 实用库也分为公共与私有的，公共的如`fsnotifier-qt`，它会被多个其他的目标使用；私有的如`mrq`，它只会被一个动态库使用，并且我们不希望它对其他目标可见，因此私有库也可以被看作附属库。

2. 公共内部库
    + 由于本仓库是一个工具集，有多个用来完成具体目标的应用程序，这些应用的业务逻辑虽然不同，但是必然使用了一部分公共的逻辑，我们将这些公共的部分抽象出来，就成为了公共内部库。
    
    + 本工程的公共内部库是QsLib，它有五个模块。事实上它最初是早期QSynthesis软件的一部分，后来经过不断的提炼与抽象，变成了如今的QsLib。

    + 因此，QsLib作为本工具集中各应用的公共依赖，需要最先完成构建。

### 程序内部库

应用程序可以是只有一个可执行文件，这样它对分发比较友好，因为只需要传输一个文件；它也可以是一个可执行文件加若干个动态库，这样它的模块化更强，可维护性更好。

本工具集有多个应用程序，每个程序拥有专门属于自己的几个动态库，这些库就是程序内部库，不同程序的程序内部库不应当有大量交集，因为这些交集可以提取到公共内部库中。

1. LabelVoice
    + LvCore
    + LvElement
    + LvStaging

2. QSynthesis
    + QUtaCore
    + QUtaStaging

## 插件

本工具集按照Qt插件标准开放一系列插件接口，插件最后会被编译成动态库，但是它仅仅作为实现而不提供自己的接口。

本工具集中的插件分为两种，公共插件与程序插件。

### 公共插件

本工程的公共插件为QsLib插件，在QsLib中定义了一系列的接口，开发者可以建立自己的插件子工程去实现这些接口。

+ 接口种类
    + IAudioDecoder
    + IAudioEncoder
    + IAudioPlayback
    + ICompressEngine
    + ISVSConverter
    + IWindowFactory

+ 目前只有SVSConverter需要开发者提供更多的实现，其他接口的默认实现已能满足需求。

### 程序插件

本工具集中每个应用程序有自己独立的插件接口，它们定义在程序内部库中，开发者可以建立自己的插件子工程去实现这些接口。

1. LabelVoice
    + 接口种类
        + ILVProjTemplate

2. QSynthesis
    + 接口种类
        + IOtoPlugin
        + IUtaPlugin


+ 如果一个应用程序只有可执行文件而没有程序内部库，那么提供插件接口将很麻烦。

+ 由于程序内部库是公共内部库的上层，因此程序插件可以调用所有的公共插件。

## 应用程序

### 工具程序

+ fsnotifier
    + 检测文件系统变化的独立进程

### 主程序

+ LabelVoice
    + 依赖的程序内部库以`lv`为前缀

+ QSynthesis
    + 依赖的程序内部库以`quta`为前缀
